package pkg

// Template contains the skeleton of the generated Go code.
var Template = `// Code generated by go generate; DO NOT EDIT.
package {{.Package}}

import (
	"context"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
)

var (
	// ErrInvalid{{.Type}} is the error returned when the value does not exist in the enum.
	ErrInvalid{{.Type}} = errors.New("invalid value for {{.Type}}")
)

type {{.Type}} struct {
	value string
	{{if .Unknown}}unknown bool{{end -}}
}

func (f {{.Type}}) String() string {
	return f.value
}

// FromString parses a string to fill the current struct.
func (f *{{.Type}}) FromString(ctx context.Context, str string) error {
	if f == nil {
		return fmt.Errorf("{{.Type}} must not be nil")
	}
	var err error
	*f, err = {{.TypePlural}}.NewFromString(ctx, str)
	return err
}

{{- if .DBSerializer }}
// Scan implements the sql.Scanner interface to read from the DB.
func (f *{{.Type}}) Scan(value interface{}) error {
	str := ""
	switch t := value.(type) {
	case []byte:
		str = string(t)
	case string:
		str = t
	default:
		return fmt.Errorf("scan failed: invalid value received for {{.Type}}")
	}

	res, err := {{.TypePlural}}.NewFromString(context.Background(), str)
	if err != nil {
		return err
	}

	*f = res
	return nil
}

// Value implements the driver.Valuer interface to write to the DB.
func (f {{.Type}}) Value() (driver.Value, error) {
	res := f.String()
	if res == "" {
		return nil, fmt.Errorf("value failed: cannot get value for {{.Type}}")
	}

	return res, nil
}
{{- end }}

{{- if .JSONSerializer }}
// MarshalJSON implements the json.Marshaler interface.
func (f {{.Type}}) MarshalJSON() ([]byte, error) {
	res := f.String()
	if res == "" {
		return []byte("null"), nil
	}

	res = "\"" + res + "\""
	return []byte(res), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface.
func (f *{{.Type}}) UnmarshalJSON(b []byte) error {
	var s string
	err := json.Unmarshal(b, &s)
	if err != nil {
		return fmt.Errorf("unmarshal failed: %w", err)
	}

	if s == "" {
		return nil
	}

	res, err := {{.TypePlural}}.NewFromString(context.Background(), s)
	if err != nil {
		return err
	}

	*f = res
	return nil
}
{{- end }}

{{- if .TextSerializer }}
// MarshalText implements the encoding.TextMarshaler interface.
func (s {{.Type}}) MarshalText() (text []byte, err error) {
	return []byte(s.value), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface.
func (s *{{.Type}}) UnmarshalText(text []byte) error {
	res, err := {{.TypePlural}}.NewFromString(context.Background(), string(text))
	if err != nil {
		return err
	}

	*s = res
	return nil
}
{{- end}}

func (f {{.Type}}) IsZero() bool {
	return f.value == ""
}

{{- if .Unknown}}
func (f {{.Type}}) IsUnknown() bool {
	return f.unknown
}
{{- end }}

// {{.TypePlural}} contains all possible values for the enum.
var {{.TypePlural}} = {{.TypePluralLC}}{
	{{range $key, $value := .Values}}
	{{$value}}: {{$.Type}}{value: "{{$key}}"{{if $.Unknown}}, unknown: false{{end}}},
	{{- end}}
}

// {{.TypePluralLC}} is the struct containing the static values.
type {{.TypePluralLC}} struct {
	{{range $key, $value := .Values}}
	{{$value}} {{$.Type}}
	{{- end}}
}

// NewFromString validates and returns the enum corresponding to the string.
func (f {{.TypePluralLC}}) NewFromString(ctx context.Context, str string) ({{.Type}}, error) {
	switch str {
	{{- range $key, $value := .Values }}
	case "{{ $key }}":
		return f.{{ $value }}, nil
	{{- end }}
	default:
		{{if not .Unknown -}}
		return {{.Type}}{}, fmt.Errorf("%w: %s", ErrInvalid{{.Type}}, str)
		{{- else -}}
		if str != "" {
			return {{.Type}}{value: str, unknown: true}, nil
		}
		return {{.Type}}{}, fmt.Errorf("%w: empty string", ErrInvalid{{.Type}})
		{{- end}}
	}
}

func (f {{.TypePluralLC}}) All() []{{.Type}} {
	return []{{.Type}}{
		{{range $key, $value := .Values}}f.{{ $value }},
		{{end}}
	}
}
`
