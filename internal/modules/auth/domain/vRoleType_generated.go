// Code generated by go generate; DO NOT EDIT.
package domain

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
)

var (
	// ErrInvalidRoleType is the error returned when the value does not exist in the enum.
	ErrInvalidRoleType = errors.New("invalid value for RoleType")
)

type RoleType struct {
	value string
}

func (f RoleType) String() string {
	return f.value
}

// FromString parses a string to fill the current struct.
func (f *RoleType) FromString(ctx context.Context, str string) error {
	if f == nil {
		return fmt.Errorf("RoleType must not be nil")
	}
	var err error
	*f, err = RoleTypes.NewFromString(ctx, str)
	return err
}

// MarshalJSON implements the json.Marshaler interface.
func (f RoleType) MarshalJSON() ([]byte, error) {
	res := f.String()
	if res == "" {
		return []byte("null"), nil
	}

	res = "\"" + res + "\""
	return []byte(res), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface.
func (f *RoleType) UnmarshalJSON(b []byte) error {
	var s string
	err := json.Unmarshal(b, &s)
	if err != nil {
		return fmt.Errorf("unmarshal failed: %w", err)
	}

	if s == "" {
		return nil
	}

	res, err := RoleTypes.NewFromString(context.Background(), s)
	if err != nil {
		return err
	}

	*f = res
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface.
func (s RoleType) MarshalText() (text []byte, err error) {
	return []byte(s.value), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface.
func (s *RoleType) UnmarshalText(text []byte) error {
	res, err := RoleTypes.NewFromString(context.Background(), string(text))
	if err != nil {
		return err
	}

	*s = res
	return nil
}

func (f RoleType) IsZero() bool {
	return f.value == ""
}

// RoleTypes contains all possible values for the enum.
var RoleTypes = roleTypes{

	Developer: RoleType{value: "DEVELOPER"},
	Owner:     RoleType{value: "OWNER"},
	User:      RoleType{value: "USER"},
	Viewer:    RoleType{value: "VIEWER"},
}

// roleTypes is the struct containing the static values.
type roleTypes struct {
	Developer RoleType
	Owner     RoleType
	User      RoleType
	Viewer    RoleType
}

// NewFromString validates and returns the enum corresponding to the string.
func (f roleTypes) NewFromString(ctx context.Context, str string) (RoleType, error) {
	switch str {
	case "DEVELOPER":
		return f.Developer, nil
	case "OWNER":
		return f.Owner, nil
	case "USER":
		return f.User, nil
	case "VIEWER":
		return f.Viewer, nil
	default:
		return RoleType{}, fmt.Errorf("%w: %s", ErrInvalidRoleType, str)
	}
}

func (f roleTypes) All() []RoleType {
	return []RoleType{
		f.Developer,
		f.Owner,
		f.User,
		f.Viewer,
	}
}
